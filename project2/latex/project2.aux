\relax 
\@writefile{toc}{\contentsline {section}{\tocsection {}{1}{Changeslow Algorithm}}{4}}
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{1.1}{Pseudocode\newline  }}{4}}
\@writefile{lol}{\contentsline {lstlisting}{pseudocode/pseudocode\textunderscore a1.txt}{4}}
\@writefile{toc}{\contentsline {section}{\tocsection {}{2}{Greedy Algorithm}}{4}}
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{2.1}{Pseudocode\newline  }}{4}}
\@writefile{lol}{\contentsline {lstlisting}{pseudocode/pseudocode\textunderscore a2.txt}{5}}
\@writefile{toc}{\contentsline {section}{\tocsection {}{3}{Dynamic Programming}}{5}}
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{3.1}{Pseudocode\newline  }}{5}}
\@writefile{lol}{\contentsline {lstlisting}{pseudocode/pseudocode\textunderscore a3.txt}{5}}
\@writefile{toc}{\contentsline {section}{\tocsection {}{4}{Questions}}{7}}
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{4.1}{Describe, in words, how you fill in the dynamic programming table in changedp. Justify why is this a valid way to fill the table?\newline  }}{7}}
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{4.2}{Give pseudocode for each algorithm.}}{8}}
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{4.3}{Prove that the dynamic programming approach is correct by induction. That is, prove that $T[v] = min_{v(i)Вv}{T[v-V[i]] + 1}, T[0] = 0$ is the minimum number of coins possible to make change for value v.}}{8}}
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{4.4}{Suppose V = [1, 5, 10, 25, 50]. For each integer value of A in [2010, 2015, 2020, ..., 2200] determine the number of coins that changegreedy and changedp requires. You can attempt to run changeslow however if it takes too long you can select smaller values of A and also run the other algorithms on the values. Plot the number of coins as a function of A for each algorithm. How do the approaches compare?}}{8}}
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{4.5}{Suppose $V_1$ = [1, 2, 6, 12, 24, 48, 60] and $V_2$ = [1, 6, 13, 37, 150]. For each integer value of A in [2000, 2001, 2002, ..., 2200] determine the number of coins that changegreedy and changedp requires. If your algorithms run too fast try [10,000, 10,001, 10,003, ..., 10,100]. You can attempt to run changeslow however if it takes too long you can select smaller values of A and also run all three algorithms on the values. Plot the number of coins as a function of A for each algorithm. How do the approaches compare?}}{8}}
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{4.6}{Suppose V = [1, 2, 4, 6, 8, 10, 12, ..., 30]. For each integer value of A in [2000, 2001, 2002, ..., 2200] determine the number of coins that changegreedy and changedp requires. You can attempt to run changeslow however if it takes too long you can select smaller values of A and also run all three algorithms on the values. Plot the number of coins as a function of A for each algorithm.}}{8}}
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{4.7}{For the above situations, determine (experimentally) the running times of the algorithms by fitting trend lines to the data or analyzing the log-log plot. Graph the running time as a function of A. Compare the running times of the different algorithms.}}{8}}
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{4.8}{Use the data from questions 4-6 and any new data you have generated. Plot running times as a function of number of denominations (i.e. V=[1, 10, 25, 50] has four different denominations so n=4). Does the size of n influence the running times of any of the algorithms?}}{8}}
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{4.9}{Suppose you are living in a country where coins have values that are powers of p, $V = [p^0 , p^1 , p^2 , ссс , p^n]$. How do you think the dynamic programming and greedy approaches would compare? Explain}}{9}}
\@writefile{toc}{\contentsline {section}{\tocsection {}{5}{Appendices}}{10}}
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{5.1}{Code\newline  }}{10}}
\@writefile{lol}{\contentsline {lstlisting}{code/main.py}{10}}
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{5.2}{Tests\newline  }}{11}}
\@writefile{lol}{\contentsline {lstlisting}{code/project2\textunderscore rbt.py}{11}}
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{5.3}{Questions\newline  }}{14}}
\@writefile{lol}{\contentsline {lstlisting}{code/questions.py}{14}}
\newlabel{tocindent-1}{0pt}
\newlabel{tocindent0}{0pt}
\newlabel{tocindent1}{19.4667pt}
\newlabel{tocindent2}{32.18062pt}
\newlabel{tocindent3}{0pt}
