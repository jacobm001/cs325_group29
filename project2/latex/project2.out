\BOOKMARK [1][-]{section.1}{1. Changeslow Algorithm}{}% 1
\BOOKMARK [2][-]{subsection.1.1}{1.1. Pseudocode}{section.1}% 2
\BOOKMARK [1][-]{section.2}{2. Greedy Algorithm}{}% 3
\BOOKMARK [2][-]{subsection.2.1}{2.1. Pseudocode}{section.2}% 4
\BOOKMARK [1][-]{section.3}{3. Dynamic Programming}{}% 5
\BOOKMARK [2][-]{subsection.3.1}{3.1. Pseudocode}{section.3}% 6
\BOOKMARK [1][-]{section.4}{4. Questions}{}% 7
\BOOKMARK [2][-]{subsection.4.1}{4.1. Describe, in words, how you fill in the dynamic programming table in changedp. Justify why is this a valid way to fill the table?}{section.4}% 8
\BOOKMARK [2][-]{subsection.4.2}{4.2. Give pseudocode for each algorithm.}{section.4}% 9
\BOOKMARK [2][-]{subsection.4.3}{4.3. Prove that the dynamic programming approach is correct by induction. That is, prove that T[v] = minv\(i\)≤vT[v-V[i]] + 1, T[0] = 0 is the minimum number of coins possible to make change for value v.}{section.4}% 10
\BOOKMARK [2][-]{subsection.4.4}{4.4. Suppose V = [1, 5, 10, 25, 50]. For each integer value of A in [2010, 2015, 2020, ..., 2200] determine the number of coins that changegreedy and changedp requires. You can attempt to run changeslow however if it takes too long you can select smaller values of A and also run the other algorithms on the values. Plot the number of coins as a function of A for each algorithm. How do the approaches compare?}{section.4}% 11
\BOOKMARK [2][-]{subsection.4.5}{4.5. Suppose V1 = [1, 2, 6, 12, 24, 48, 60] and V2 = [1, 6, 13, 37, 150]. For each integer value of A in [2000, 2001, 2002, ..., 2200] determine the number of coins that changegreedy and changedp requires. If your algorithms run too fast try [10,000, 10,001, 10,003, ..., 10,100]. You can attempt to run changeslow however if it takes too long you can select smaller values of A and also run all three algorithms on the values. Plot the number of coins as a function of A for each algorithm. How do the approaches compare?}{section.4}% 12
\BOOKMARK [2][-]{subsection.4.6}{4.6. Suppose V = [1, 2, 4, 6, 8, 10, 12, ..., 30]. For each integer value of A in [2000, 2001, 2002, ..., 2200] determine the number of coins that changegreedy and changedp requires. You can attempt to run changeslow however if it takes too long you can select smaller values of A and also run all three algorithms on the values. Plot the number of coins as a function of A for each algorithm.}{section.4}% 13
\BOOKMARK [2][-]{subsection.4.7}{4.7. For the above situations, determine \(experimentally\) the running times of the algorithms by fitting trend lines to the data or analyzing the log-log plot. Graph the running time as a function of A. Compare the running times of the different algorithms.}{section.4}% 14
\BOOKMARK [2][-]{subsection.4.8}{4.8. Use the data from questions 4-6 and any new data you have generated. Plot running times as a function of number of denominations \(i.e. V=[1, 10, 25, 50] has four different denominations so n=4\). Does the size of n influence the running times of any of the algorithms?}{section.4}% 15
\BOOKMARK [2][-]{subsection.4.9}{4.9. Suppose you are living in a country where coins have values that are powers of p, V = [p0 , p1 , p2 , ··· , pn]. How do you think the dynamic programming and greedy approaches would compare? Explain}{section.4}% 16
\BOOKMARK [1][-]{section.5}{5. Appendices}{}% 17
\BOOKMARK [2][-]{subsection.5.1}{5.1. Code}{section.5}% 18
\BOOKMARK [2][-]{subsection.5.2}{5.2. Tests}{section.5}% 19
\BOOKMARK [2][-]{subsection.5.3}{5.3. Questions}{section.5}% 20
\BOOKMARK [2][-]{subsection.5.4}{5.4. Figures}{section.5}% 21
