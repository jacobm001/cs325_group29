\contentsline {section}{\tocsection {}{1}{Changeslow Algorithm}}{3}{section.1}
\contentsline {subsection}{\tocsubsection {}{1.1}{Pseudocode}}{3}{subsection.1.1}
\contentsline {section}{\tocsection {}{2}{Greedy Algorithm}}{3}{section.2}
\contentsline {subsection}{\tocsubsection {}{2.1}{Pseudocode}}{3}{subsection.2.1}
\contentsline {section}{\tocsection {}{3}{Dynamic Programming}}{4}{section.3}
\contentsline {subsection}{\tocsubsection {}{3.1}{Pseudocode}}{4}{subsection.3.1}
\contentsline {section}{\tocsection {}{4}{Questions}}{6}{section.4}
\contentsline {subsection}{\tocsubsection {}{4.1}{Describe, in words, how you fill in the dynamic programming table in changedp. Justify why is this a valid way to fill the table?}}{6}{subsection.4.1}
\contentsline {subsection}{\tocsubsection {}{4.2}{Give pseudocode for each algorithm.\newline }}{7}{subsection.4.2}
\contentsline {subsection}{\tocsubsection {}{4.3}{Prove that the dynamic programming approach is correct by induction. That is, prove that $T[v] = min_{V(i)Вv}{T[v-V[i]] + 1}, T[0] = 0$ is the minimum number of coins possible to make change for value v.}}{7}{subsection.4.3}
\contentsline {subsection}{\tocsubsection {}{4.4}{Suppose V = [1, 5, 10, 25, 50]. For each integer value of A in [2010, 2015, 2020, ..., 2200] determine the number of coins that changegreedy and changedp requires. You can attempt to run changeslow however if it takes too long you can select smaller values of A and also run the other algorithms on the values. Plot the number of coins as a function of A for each algorithm. How do the approaches compare?}}{7}{subsection.4.4}
\contentsline {subsection}{\tocsubsection {}{4.5}{Suppose $V_1$ = [1, 2, 6, 12, 24, 48, 60] and $V_2$ = [1, 6, 13, 37, 150]. For each integer value of A in [2000, 2001, 2002, ..., 2200] determine the number of coins that changegreedy and changedp requires. If your algorithms run too fast try [10,000, 10,001, 10,003, ..., 10,100]. You can attempt to run changeslow however if it takes too long you can select smaller values of A and also run all three algorithms on the values. Plot the number of coins as a function of A for each algorithm. How do the approaches compare?}}{8}{subsection.4.5}
\contentsline {subsection}{\tocsubsection {}{4.6}{Suppose V = [1, 2, 4, 6, 8, 10, 12, ..., 30]. For each integer value of A in [2000, 2001, 2002, ..., 2200] determine the number of coins that changegreedy and changedp requires. You can attempt to run changeslow however if it takes too long you can select smaller values of A and also run all three algorithms on the values. Plot the number of coins as a function of A for each algorithm.}}{8}{subsection.4.6}
\contentsline {subsection}{\tocsubsection {}{4.7}{For the above situations, determine (experimentally) the running times of the algorithms by fitting trend lines to the data or analyzing the log-log plot. Graph the running time as a function of A. Compare the running times of the different algorithms.}}{9}{subsection.4.7}
\contentsline {subsection}{\tocsubsection {}{4.8}{Use the data from questions 4-6 and any new data you have generated. Plot running times as a function of number of denominations (i.e. V=[1, 10, 25, 50] has four different denominations so n=4). Does the size of n influence the running times of any of the algorithms?}}{10}{subsection.4.8}
\contentsline {subsection}{\tocsubsection {}{4.9}{Suppose you are living in a country where coins have values that are powers of p, $V = [p^0 , p^1 , p^2 , ссс , p^n]$. How do you think the dynamic programming and greedy approaches would compare? Explain}}{10}{subsection.4.9}
\contentsline {section}{\tocsection {}{5}{Appendices}}{11}{section.5}
\contentsline {subsection}{\tocsubsection {}{5.1}{Code\newline }}{11}{subsection.5.1}
\contentsline {subsection}{\tocsubsection {}{5.2}{Tests\newline }}{12}{subsection.5.2}
\contentsline {subsection}{\tocsubsection {}{5.3}{Questions\newline }}{15}{subsection.5.3}
\contentsline {subsection}{\tocsubsection {}{5.4}{Figures}}{18}{subsection.5.4}
