\relax 
\providecommand\HyperFirstAtBeginDocument{\AtBeginDocument}
\HyperFirstAtBeginDocument{\ifx\hyper@anchor\@undefined
\global\let\oldcontentsline\contentsline
\gdef\contentsline#1#2#3#4{\oldcontentsline{#1}{#2}{#3}}
\global\let\oldnewlabel\newlabel
\gdef\newlabel#1#2{\newlabelxx{#1}#2}
\gdef\newlabelxx#1#2#3#4#5#6{\oldnewlabel{#1}{{#2}{#3}}}
\AtEndDocument{\ifx\hyper@anchor\@undefined
\let\contentsline\oldcontentsline
\let\newlabel\oldnewlabel
\fi}
\fi}
\global\let\hyper@last\relax 
\gdef\HyperFirstAtBeginDocument#1{#1}
\providecommand\HyField@AuxAddToFields[1]{}
\@writefile{toc}{\contentsline {section}{\tocsection {}{1}{Changeslow Algorithm}}{4}{section.1}}
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{1.1}{Pseudocode\newline  }}{4}{subsection.1.1}}
\@writefile{lol}{\contentsline {lstlisting}{pseudocode/pseudocode\textunderscore a1.txt}{4}{lstlisting.-1}}
\@writefile{toc}{\contentsline {section}{\tocsection {}{2}{Greedy Algorithm}}{4}{section.2}}
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{2.1}{Pseudocode\newline  }}{4}{subsection.2.1}}
\@writefile{lol}{\contentsline {lstlisting}{pseudocode/pseudocode\textunderscore a2.txt}{5}{lstlisting.-2}}
\@writefile{toc}{\contentsline {section}{\tocsection {}{3}{Dynamic Programming}}{5}{section.3}}
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{3.1}{Pseudocode\newline  }}{5}{subsection.3.1}}
\@writefile{lol}{\contentsline {lstlisting}{pseudocode/pseudocode\textunderscore a3.txt}{5}{lstlisting.-3}}
\@writefile{toc}{\contentsline {section}{\tocsection {}{4}{Questions}}{7}{section.4}}
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{4.1}{Describe, in words, how you fill in the dynamic programming table in changedp. Justify why is this a valid way to fill the table?\newline  }}{7}{subsection.4.1}}
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{4.2}{Give pseudocode for each algorithm.\newline  }}{8}{subsection.4.2}}
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{4.3}{Prove that the dynamic programming approach is correct by induction. That is, prove that $T[v] = min_{v(i)²v}{T[v-V[i]] + 1}, T[0] = 0$ is the minimum number of coins possible to make change for value v.}}{8}{subsection.4.3}}
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{4.4}{Suppose V = [1, 5, 10, 25, 50]. For each integer value of A in [2010, 2015, 2020, ..., 2200] determine the number of coins that changegreedy and changedp requires. You can attempt to run changeslow however if it takes too long you can select smaller values of A and also run the other algorithms on the values. Plot the number of coins as a function of A for each algorithm. How do the approaches compare?}}{8}{subsection.4.4}}
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{4.5}{Suppose $V_1$ = [1, 2, 6, 12, 24, 48, 60] and $V_2$ = [1, 6, 13, 37, 150]. For each integer value of A in [2000, 2001, 2002, ..., 2200] determine the number of coins that changegreedy and changedp requires. If your algorithms run too fast try [10,000, 10,001, 10,003, ..., 10,100]. You can attempt to run changeslow however if it takes too long you can select smaller values of A and also run all three algorithms on the values. Plot the number of coins as a function of A for each algorithm. How do the approaches compare?}}{8}{subsection.4.5}}
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{4.6}{Suppose V = [1, 2, 4, 6, 8, 10, 12, ..., 30]. For each integer value of A in [2000, 2001, 2002, ..., 2200] determine the number of coins that changegreedy and changedp requires. You can attempt to run changeslow however if it takes too long you can select smaller values of A and also run all three algorithms on the values. Plot the number of coins as a function of A for each algorithm.}}{9}{subsection.4.6}}
\@writefile{toc}{\contentsline {subsection}{\tocsubsection {}{4.7}{For the above situations, determine (experimentally) the running times of the algorithms by fitting trend lines to the data or analyzing the log-log plot. Graph the running time as a f